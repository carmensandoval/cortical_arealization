---
title: "Constellation Plots: Neocortex, 2nd Trimester" 
subtitle: "All Samples, All cell types"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

```{r global_options, include=FALSE}

knitr::opts_chunk$set(fig.width=12, fig.height=8, fig.path = 'Figs/',
                      echo = FALSE, warning = FALSE, message = FALSE)
```

# TO-DO
- Constellation plots for cell type / area groups.
  - Color by cell type, use label for area only.
  - Return function color.by to "clade"
  
- Plot cells as dots? To show how representative the centroid node is.

*** 

# Load data

• Neocortex_v3.RData
Not necessary if just plotting on already calculated PCA, UMAP, clusters.
```{r load-neocortex, eval = FALSE, echo=TRUE}
# Full dataset:
ncx.exn <- read_rds("../data/exn_lineage/neocortex_exn_lineage_271k.rds")

# 40k random subset (toy dataset)
# ncx.40k <- read_rds("constellation_plots/ncx_v3_40k.rds")

# 100k random subset of excitatory neuron lineage only.
ncx.exn.100k <- read_rds("../data/exn_lineage/toy/ncx.v3.exn.sub_100k.rds")
```

• Cluster / marker tables.
```{r load-tbls,  echo=TRUE, paged.print=TRUE}
ncx.clusters <- read_delim("../tbls/83d19_Neocortex_allindividuals_combinedclusters_v1.txt",
                              "\t", escape_double = FALSE, trim_ws = TRUE)

ncx.markers <- read_delim("../tbls/8f0fc_Neocortex_subset1_clustermarkers_combo2.txt", 
                  "\t", escape_double = FALSE, trim_ws = TRUE)
```

***

# `scrattch.hicat` steps to build constellation plots.
Calls `buildConstellation.Rmd`.

## 1. Define cells to build the plot from.
  
### a. All clusters / cell types:
[All cells: 404.2K]

Keep only cells with *_combo2_* `$combined.cluster.2` annotation.
```{r eval=FALSE}

cells.cl.df <-  ncx.clusters %>% filter(str_detect(combined.cluster.2, "combo2"))

s.obj <- Neocortex %>% subsetSeurat(cells.keep = cells.cl.df$cell.name)
# 348K cells

# Sanity check
cells.cl.df$cell.name %>% identical(s.obj@meta.data %>% rownames)
[TRUE]
```

### b. Excitatory neuron lineage only:

Keep only cells with *_combo2_* `$combined.cluster.2` annotation AND
whose `$combined.cluster.2` annotation belongs to excitatory neuronal lineage classes.
```{r eval=FALSE}
cells.cl.df <- ncx.clusters.exn <- 
                  ncx.clusters %>% 
                      filter(str_detect(combined.cluster.2, "combo2") ) %>% 
                        filter(str_detect(combined.cluster.2, "Neuron|CR|Dividing|RG|IPC|OPC") )


s.obj <- Neocortex %>% subsetSeurat(cells.keep = cells.cl.df$cell.name)
# 271.4K cells in excitatory lineage.

# Remove @counts slot (5GB)
# s.obj@assays$RNA@counts <- matrix(c(0,0))

# Sanity check:
cells.cl.df$cell.name %>% identical(s.obj@meta.data %>% rownames)
# [TRUE]

s.obj@meta.data <- left_join(x = s.obj@meta.data %>% select(-orig.ident) %>% rownames_to_column("cell.name"),
                             y = cells.cl.df[ , c("cell.name", "combined.cluster.2")]) %>% 
                      set_rownames(.$cell.name)

# write_rds(s.obj, "../data/exn_lineage/neocortex_exn_lineage_271k.rds", compress = "gz")
```

***
# 2. Build dfs and constellation plot.
```{r}
ncx.exn@meta.data
```

```{r}
rd.dat <- list(umap = ncx.exn@reductions$umap@cell.embeddings,
               pca = ncx.exn@reductions$pca@cell.embeddings)

cells.cl.df <- ncx.exn@meta.data

rmarkdown::render("buildConstellation.Rmd", 
                  params = list(cells.cl.df = cells.cl.df,
                                rd.dat = rd.dat,
                                 groups.col = "group"
                                 )
)
```

```{r}
ncx.exn@reductions %>% str
```


****************************************************************************************************

# 3. DE genes
Find DE genes between connected clusters/nodes.

```{r diffexp}

# Dataframe w/ the proportion of k(15) nearest neighbors in each cluster for every cell.
nn.cl.df <- knn.cl$pred.result$pred.prob %>% as.data.frame

cl.df$cluster_id %<>% as.factor()
# Possibly move to top, before making all DFs.
cells.cl.df %<>% rename(cluster_label = "combined.cluster.2") %>% 
                  mutate(cluster_label = str_remove(cluster_label, "_combo2"))

cl.df %<>% mutate(cluster_label = str_remove(cluster_label, "_combo2"))


# Add column with cells' own cluster assignment from `cells.cl.df`.
nn.cl.df %<>% left_join(cells.cl.df,
                        by = c("query" = "cell.name")
                        )
# Add cluster_label corresponding to nn.cl.

nn.cl.df %<>% left_join(cl.df %>% select(cluster_label, cluster_id),
                        by = c("nn.cl" = "cluster_id"))

nn.cl.df %<>% select(query, cluster_id_self = "cluster_id", 
                    cluster_label_self = "cluster_label.x",
                    cluster_id_nn = "nn.cl",
                    cluster_label_nn = "cluster_label.y",
                    freq = "Freq")

# nn.cl.df %<>% select(query, combined.cluster.2, cluster_id, nn.cl, )

```

```{r}
x <- filter(knn.cl$knn.cl.df, frac >= 0.1 & cl.from != cl.to) %>% arrange(cl.from)
```

```{r}
knn.cl$knn.cl.cl.counts %>% head
```

```{r}
cl.df

x <- filter(nn.cl.df, cluster_label_self == "Neuron_8" & cluster_label_nn == "Neuron_3")
# 12,201 cells in Neuron_8

x %>% filter(freq > 0) %>% 
  ggplot() + geom_density(aes(freq))
```

## Find `cluster_a` cells with nearest neighbors in `cluster_b`.

```{r}
# cell.cl.counts: matrix of all cells and their counts of nearest neighbors in each cluster.
cell.cl.counts <- knn.cl$knn.cell.cl.counts %>% as.data.frame.matrix %>% rownames_to_column("cell.name")

cell.cl.counts <- left_join(cells.cl.df, cell.cl.counts,  by = "cell.name") %>%
  select(-cell.type) %>% mutate(combined.cluster.2 = str_remove(combined.cluster.2, "_combo2")) %>%
  rename(cluster_label = "combined.cluster.2")


names(cell.cl.counts)[4:ncol(cell.cl.counts)] %<>% paste0("cl_", .)
```

# Find cells in `cluster_a` with nearest neighbors in `cluster_b`
```{r echo=TRUE}
cluster_a <- "IPC_6"
cluster_b <- "IPC_3"

cluster_b_col <- cell.cl.counts %>% filter(cluster_label == cluster_b) %>% 
                .$cluster_id %>% as.numeric %>% unique %>% paste0("cl_", .)


x <- cell.cl.counts %>% filter(cluster_label == cluster_a) %>% replace(is.na(.), 0)

nn.counts <- x[[cluster_b_col]]

df <- list(
n.cells.clust.a = length(x$cell.name),
with.neighbors = sum(nn.counts > 0),
no.neighbors = sum(nn.counts == 0),
median.nnCounts = median(nn.counts[nn.counts > 0])
)

as.tibble(df)


```

## Find median.
Distribution of neighbor counts in cluster_b for cells in a given cluster_a.
Use this to find the point at which cells will be split into comparison groups.
```{r median}
  ggplot(x) + 
    ggtitle(paste(cluster_a, "cells \n n/k=15 nearest neighbors in", cluster_b)) +
    
    geom_bar(aes(x = get(cluster_b_col))) +
    geom_vline(xintercept = median.nnCounts, colour = "red") +
    annotate("text", x = median.nnCounts + 1, y = quantile(1: n.cells, .07),
             label = paste0("median = ", median.nnCounts)
  ) + 
    xlab(paste("# of", cluster_b, "neighbors")) +
    ylab("") +
    theme_minimal() 
```

## FindMarkers 
Compare cells above and below the median count of `cluster_b` neighbors.
```{r findmarkers, echo=TRUE}
cells <- list()
cells$above.median <- x %>% filter(get(cluster_b_col) > median.nnCounts) %>% pull(cell.name)
cells$below.median <- x %>% filter(get(cluster_b_col) < median.nnCounts)  %>% pull(cell.name)

cells$other <- setdiff(s.obj@meta.data$cell.name, flatten_chr(cells))


s.obj <- SetIdent(object = s.obj, cells = cells$above.median, value = 'nn_ct_above_med') %>% 
                SetIdent(cells = cells$below.median, value = 'nn_ct_below_med') %>%
                SetIdent(cells = cells$other, value = 'other')

cells <- cells[1:2]

s.obj@active.ident %>% table %>% as.data.frame()
# nn_ct_below_med	7594			
# nn_ct_above_med	2557	

# Make sure @counts slot is present for slot = "scale.data" to work.
markers <- FindMarkers(s.obj, slot = "scale.data",
                          # features = s.obj@assays$RNA@var.features,
                                  ident.1 = "nn_ct_above_med", 
                                  ident.2 = "nn_ct_below_med", 
                                  logfc.threshold = 0)

```

## Clean DE genes table.
Calculate enrichment ratio, filter genes w. adj p-value < 0.05, sort table.
Positive values indicate that the feature is more highly expressed in the first group.
```{r filter-markers, echo=TRUE}
markers %<>% rownames_to_column("gene") %>%
  mutate(enrich.ratio = pct.1 / pct.2,
         gene.score = avg_diff * enrich.ratio # what does this do to down genes?
         
markers$filter <- 
         # , across(.cols = where(is.numeric), .fns = round, digits = 4)
  ) %>%
  filter(p_val_adj <= 0.01) %>% 
  filter(pct.1 >= 0.5 | pct.2 >= 0.5) %>%
  select(gene, pct.1, pct.2, enrich.ratio, avg_diff, gene.score, avg_diff, p_val_adj) %>%
  arrange(desc(gene.score))

markers.tmp[2:6] %<>% round(5)

write_tsv(markers.tmp, path =  paste0("../out/DEgenes_", cluster_a, "_vs_", cluster_b, "scale.data.tsv"))

```

```{r reactable-table}
reactable(markers.tmp, defaultPageSize = 100,
          showSortable = TRUE, resizable = TRUE, highlight = TRUE, filterable = TRUE, minRows = 10,
          style = list(fontFamily = "Work Sans, sans-serif", fontSize = "12px")
  )
```

```{r}
# saveWidget(markers.tmp, file = )

# Same genes in both comparisons (sanity check)
xtab_set <- function(A,B){
              both    <-  union(A,B)
              inA     <-  both %in% A
              inB     <-  both %in% B
              return(table(inA,inB))
            }
# xtab_set(markers$nn_above_med$geme, markers$nn_below_med$gene)
```

****************************************************************************************************

# DE genes heatmap:

Requires: 
- Seurat object
- cells.to.plot (chr vector)
- markers.to.plot (chr vector)
```{r build-heatmap}

# Filter markers to include in heatmap by enrichment ratio.
markers.to.plot <- markers.tmp %>% filter(enrich.ratio >= 1.3 | enrich.ratio <= 0.7) %>%
  arrange(desc(enrich.ratio)) %>% pull(gene)

cells.to.plot <- flatten_chr(cells)

# Get 1st and 99th percentiles to choose the limits for color scale. (clip outliers)
(exp.limits <- s.obj@assays$RNA@scale.data[markers.to.plot, cells.to.plot] %>% as.numeric %>%
                  quantile(c(0, 0.01, 0.05, 0.1, 0.5, 0.9, 0.95, 0.99, 1)))

message(paste("Building heatmap for", length(markers.to.plot), "genes and", length(cells.to.plot), "cells."))


heatmap <- 
  Seurat::DoHeatmap(s.obj, 
            cells = cells.to.plot,
            features =  markers.to.plot,
            disp.min = exp.limits["1%"],
            disp.max = exp.limits["99%"],
            angle = 0,
            slot = "scale.data"
          # slim.col.label = TRUE,
          # remove.key = TRUE
  ) +
  theme(legend.text = element_text(size = 8),
        legend.position = "bottom",
        #legend.position = "none",
        text = element_text(size = 8),
        aspect.ratio = c(2,1)
  ) +
    scale_fill_viridis(end = 1, na.value = 'white', option = "magma", discrete = FALSE)

ggsave(heatmap, filename = paste0("../out/DEgenes_", cluster_a, "_vs_", cluster_b, "scale.data_heatmap.pdf") )

saveplot(filename = paste0("../out/DEgenes_", cluster_a, "_vs_", cluster_b, "scale.data_heatmap.pdf"),heatmap )
#, width = 11, height = 8, units = "in"
p <- ggplotly(heatmap, tooltip = "Feature", width = 1000, height = 800) %>% 
      layout(legend = list(yanchor = 'bottom', orientation = 'h')) %>% partial_bundle()


# Remove group key.
# plotly_json(p)
p$x$data[c(2,3)] <- NULL

# saveWidget("~/carmensandoval.github.io/arklab/2nd-tri/clustering/DEgenes_", cluster_a, "_vs_", cluster_b, "scale.data.html", selfcontained = TRUE)

saveWidget(p, paste0("../out/DEgenes_", cluster_a, "_vs_", cluster_b, "scale.data_heatmap.html"), selfcontained = TRUE)
```

***

# Constellation plots by cell type-area groups.

## 1. Add a cell.type-area column to metadata.
```{r }
ncx.exn@meta.data %<>% 
  mutate(combined.cluster.2 = str_remove(combined.cluster.2, "_combo2"),
         cell.type = str_replace(combined.cluster.2, "_[:digit:]+", replacement = "")) %>% 
  unite(col = "cell.type.area.indiv", cell.type, Area, Individual, sep = "-", remove = FALSE) %>%
  unite(col = "cell.type.area", cell.type, Area, sep = "-", remove = FALSE)
```

Make sure there are 271k cells in metadata.
```{r}
ncx.exn@meta.data %>% dplyr::count(cell.type)
```


```{r}
ncx.exn@meta.data %>% dplyr::count(cell.type.area)
```

## 2. Make constellation plot.

Call `buildConstellation.Rmd`, which has all the steps required to make dfs and plot.
Takes arguments: `cells.cl.df`, `groups.col`, `colors.use` and `rd.dat`.

```{r call-buildCLplot}

reductions <- list(umap = ncx.exn@reductions$umap@cell.embeddings,
                   pca  = ncx.exn@reductions$pca@cell.embeddings)

# Colors for areas:
# Add clade_id, clade_color to cl.df
colors.area <- data.frame(
                 c("motor" = "#007EB8", #command-blue
                "parietal" = "#0CD4AD", #caribbean-green
                 "pfc" = "#FF0558", #folly-red
                 "somatosensory" = "#FDD913", # yellow
                 "v1" = "#FE8499", #tulip-pink
                 "temporal" = "#C487F6" #pale-violet
                )  
              ) %>% rownames_to_column("group")


# Colors for cell types:
colors.clade <- data.frame(# clade = unique(cl.df$clade),
                        cluster_color = c("cr"= "darkgrey", 
                                  "dividing" = "darkkhaki", 
                                  "neuron" = "deepskyblue", 
                                  "inteneuron" = "deeppink2", 
                                  "ipc" = "brown4", 
                                  "microglia" = "darkorchid1",
                                  "opc" = "cadetblue", 
                                  "other" = "darkslateblue", 
                                  "rg" = "darkorange", 
                                  "vascular" = "blanchedalmond")
            ) %>% rownames_to_column("group")


rmarkdown::render("buildConstellation.Rmd", 
                  params = list(cells.cl.df = ncx.exn@meta.data,
                                rd.dat = reductions,
                                 groups.col = "cell.type.area",
                                 colors.use = colors.clade
                                 )
           )
```






# Other functions
```{r functions}
.env$source_rmd <- function(file, local = FALSE, ...){
  options(knitr.duplicate.label = 'allow')

  tempR <- tempfile(tmpdir = ".", fileext = ".R")
  on.exit(unlink(tempR))
  knitr::purl(file, output = tempR, quiet = TRUE)

  envir <- globalenv()
  source(tempR, local = envir, ...)
}

.env$reactable <- function(...) {
  htmltools::tagList(reactable::reactable(...))
}

# source("../../../code_general/setup_R_session_CSE.R")

attach(.env)
```