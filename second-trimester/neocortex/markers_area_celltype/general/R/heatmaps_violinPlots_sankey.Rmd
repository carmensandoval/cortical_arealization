---
title: "Heatmaps: DE genes: cell types across brain regions (whole brain)"
output: html_notebook
---

```{r}
p_load(data.table)
p_load(ggdendro)
p_load(widyr)
p_load(networkD3)
p_load(cowplot)
p_load(heatmaply)
p_load(BBmisc)
p_load(manipulateWidget)
p_load(fs)
```

# Load data
```{r}
ncx.exn <- read_rds("~/cse-phd/second-trimester/neocortex/ncx_data/exn_lineage/neocortex_exn_lineage_271k.rds")

# All neocortex (not just excitatory lineage)
"~/cse-phd/second-trimester/neocortex/ncx_data/cfc4b2_neocortex_v3.RData"
```


# Brain region markers: by cell type
For each cell type, get the top marker genes for each area.

Read-in cell-type/areal marker genes

## Individuals separately
- Compare genes across individuals?
How consistent is the areal signature across age for a given cell type?
```{r}

# dir <- "~/Dropbox/2nd Trimester Areas Paper/Area Specific Genes/Neuron_byarea_combined.txt"
dir <- "../tbls_markers_by_celltype_and_area/"
files <- fs::dir_ls(dir, regexp = "txt")
       

cell.type <- c("rg", "neuron", "ipc") %>% as.list %>% set_names(unlist(.))

# files <- files[str_detect(tolower(files), cell.type$rg)]

read_and_add <- function(file) {
  
     metadata <- str_match(file, ".*/(.*)_neocortex_(.*)_byarea.*") %>% tolower
     df = read.table(file)
     
     df$individual = metadata[2]
     df$celltype = metadata[3]
     
     df %<>% select(gene, everything()) %>% rename(area = "cluster")
     return(df)
}


markers <- map_dfr(.x = files,
                  .f = read_and_add)

markers %<>% mutate(pct.2 = pct.2 + 0.001,
                    gene.ratio = pct.1 / pct.2,
                    gene.score = avg_logFC * gene.ratio
                    )
```

# Older instructions
```{r}
markers.ct[[cell.type]] <- lapply(files, function(x){
  
                 read.delim(x) %>% 
                  mutate(gene.ratio = pct.1 / pct.2,
                         gene.score = avg_logFC * gene.ratio
                        ) 
                  }) %>%
  
 set_names(value = files %>% tolower %>% 
          str_match(pattern = ".*/(.*)_neocortex.*") %>% .[,2]) %>%
  
           purrr::imap( ~mutate(.x, individual = .y))

markers.ct[[cell.type]]$all.indiv <- markers.ct[[cell.type]] %>% 
                                rbindlist()
```

## Bin all genes into areas
```{r}
genes.areas <- list()

genes.areas[[cell.type]] <- markers.ct[[cell.type]]$all.indiv %>%  
          select(-X) %>% 
            dplyr::filter(p_val_adj <= 0.05) %>%
              group_by(cluster) %>% 
                group_modify(~ .x %>% group_by(gene) %>% 
                                       add_count(name = "n", sort = TRUE) %>% ungroup %>%
                                         select(gene, n, individual, everything())
                                       )  %>%
    group_split()
    
genes.areas[[cell.type]] %<>% set_names(., value = map(.x = ., ~first(.x$cluster)))
              

  # purrr::map(~ dplyr::count(.x , ..1 = cluster, ..2 = individual))

```
# /////////////////////////////////////////////////////////////////////////////////////////////////

## Exploration: gene scores, p_values, etc. 
```{r}
markers.ct$neuron$all.indiv %>% filter(cluster == "PFC") %>% group_by(individual) %>% 
  summarise(min(gene.ratio), max(gene.ratio), min(gene.score), max(gene.score), min(avg_logFC ), max(avg_logFC))
```

```{r}
markers.ct$neuron$all.indiv %>% filter(cluster == "PFC") %>% add_count(individual) %>% 
  ggplot() +
  geom_jitter(aes(individual, gene.ratio, colour = individual)) +
  scale_y_continuous(limits = c(0, 25)) +
  geom_label(aes(individual, 0, label = n))
```

```{r}
markers.ct$neuron$all.indiv %>% dplyr::filter(cluster == "PFC") %>% add_count(individual) %>%

  ggplot() +
  geom_jitter(aes(individual, avg_logFC, colour = individual)) +
  scale_y_continuous(limits = c(0, 2.75)) +
  geom_label(aes(individual, 0, label = n))


```

```{r}
genes$ %>% arrange(p_val_adj) %>%

  ggplot() +
  geom_jitter(aes(individual, gene.score, colour = p_val_adj, alpha = p_val_adj), size = 1) +
  scale_y_continuous(limits = c(0, 25)) +
  geom_label(aes(individual, 20, label = n)) +
  scale_color_gradient(low = "blue", high = "red", limits= c(0, 0.05)) +
  theme_minimal()

# Max is 50
```

```{r}
markers.ct$neuron$all.indiv %>% dplyr::filter(cluster == "PFC") %>% n_distinct(.$gene)
# 1,108

markers.ct$neuron$all.indiv %>% dplyr::filter(cluster == "PFC" & p_val_adj < 0.05) %>% n_distinct(.$gene)
# 981

markers.ct$neuron$all.indiv %>% dplyr::filter(cluster == "PFC" & p_val_adj <= 0.05) %>% add_count(individual) %>%

  ggplot(aes(x = individual, y = p_val_adj, colour = individual)) +
  geom_jitter(alpha = 0.5, size = 0.5) +
  geom_label(aes(individual, 0.025, label = n)) +
  theme_minimal()
  # scale_y_continuous(limits = c(0, 0.05))
  
```

## Genes per individual / per area
```{r}

colors.area$area %<>% factor(. , levels = .)
markers.ct$neuron %>% lapply(function(x) dplyr::count(x, cluster, individual))

markers.ct$neuron$all.indiv %>% dplyr::filter(p_val_adj <=0.05) %>% 
  dplyr::count(cluster, individual) %>%
  mutate(cluster = factor(cluster, levels = colors.area$area)) %>%
  
  ggplot() +
  geom_label(aes(cluster, individual, size = n, label = n, fill = cluster),
             color = "white", label.r = unit(0.3, "lines")
             ) +
  
  scale_x_discrete(breaks = colors.area$area) +
  scale_fill_manual(values = colors.area$color) +
  
  theme_minimal() + 

  guides(color = FALSE,
         size = FALSE,
         fill = FALSE) +
    
  theme(axis.text.x = element_text(angle = 35),
        text = element_text(size = 12),
        axis.title = element_blank()
        ) +
    
    ggtitle(label = "DE genes: Neurons")
  
  
  pivot_wider(id_cols = cluster, names_from = individual, values_from = n)
```



# ///////////////////////////////////////////////////////////////////////////////////////////////////
# Run clustering

## Make wide matrix for hierarchical clustering / dendrogram
```{r}
lapply(genes.areas$neurons, function(x) {
  
          x %<>% select(gene, individual, gene.score) %>% 
                pivot_wider(values_fill = 0,  
                            values_from = gene.score,  
                            names_from = individual, 
                            id_cols = gene)
            
          dd <- x %>% select(-gene) %>% 
                  as.matrix %>% set_rownames(x$gene) %>%
                    dist %>% hclust %>% dendro_data
       }
)
```

## Draw dendrogram
```{r}
cols <-  colors.use$cluster_color
  p <- plot_ggdendro(dd,
                   direction   = "tb", label.size = 1, scale.color = cols, branch.size = 0.5)
  
p

ggsave(p , filename = "../violinPlots/neocortex_DEgenes_by_celltype_area/dendrotest.pdf", height = 5, width = 20)

ggdendrogram(rotate = TRUE, size = 2) %>% ggsave(filename = "../violinPlots/neocortex_DEgenes_by_celltype_area/dendrotest.pdf", height = 11, width = 5)
```

# Heatmap: Gene scores
```{r}

g <-  g %>% pivot_longer( cols = 2:9, values_to = "gene.score",  names_to = "individual") %>% 
          dplyr::na_if(0) %>%
          mutate(gene.score = round(gene.score, 2)
                  # gene = factor(gene, levels = dd$labels$label)
          ) %>% left_join(genes$PFC %>% select(-X, -individual, -gene.score), by = "gene") 

g$gene <- factor(g$gene, levels = dd$labels$label)

```

# Heatmap: Gene scores
```{r make-heatmaps}

heatmaps <- list()

heatmaps$range <- lapply(2:7, function(x) {
  
  print(x)
  df <- genes$PFC.pval %>% dplyr::filter(n >= x)
  
  p <- heatmapGenes(df = df, 
             color.by = gene.score, max.value = 5, 
             title = paste("Neurons: PFC: n >=", x, ":", n_distinct(df$gene), "genes")
  )
  return(p)
  
}
)

heatmaps$bin <- lapply(1:7, function(x) {
  
  df <- genes$PFC.pval %>% dplyr::filter(n == x)
  
  p <- heatmapGenes(df = df, 
             color.by = gene.score, max.value = 5, 
             title = paste("Neurons: PFC: n =", x, ":", n_distinct(df$gene), "genes")
  )
  return(p)
  
}
)



pdf(file = "../violinPlots/neocortex_DEgenes_by_celltype_area/heatmap_markers_neuron_PFC.pdf", onefile = TRUE, width = 30, height = 20)

patchwork::wrap_plots(heatmaps$range, ncol = 2, nrow = 4, guides = "collect", byrow = FALSE)
patchwork::wrap_plots(heatmaps$bin, ncol = 2, nrow = 4, guides = "collect", byrow = FALSE)
dev.off()

df <- g %>% dplyr::filter(n == 1)

heatmaps$single <-   heatmapGenes(df = df, 
             color.by = gene.score, max.value = 5, 
             title = paste("Neurons: PFC: n = 1", ":", n_distinct(df$gene), "genes")
)

# patchwork::wrap_plots(heatmaps, ncol = 3, guides = "collect", legend.position = "bottom", nrow = 3)
```



heatmapGenes <- function(markers.df, n.genes, color.by, max.value, title) {

color.by <- enquo(color.by)


## fxn: clusterGenes  
```{r fxn-heatmapGenes}

# Cluster genes
# Keep only genes with pval_adj <= 0.5
# Make wide matrix of gene scores, by genes x individual.
# Run hierarchical clustering and get gene order from dendrogram labels.

# marker.genes.df <- genes$motor
# n.genes <- 1

clusterGenes <- function(marker.genes.df, n.genes) {
  
          x <- marker.genes.df %>% dplyr::filter(p_val_adj <= 0.05 & n == n.genes) %>% 
                  mutate(gene.score = round(gene.score, 3))

# Hierarchical clustering
# Get dist matrix, run hcust, extract ordered labels.
         if(n_distinct(x$gene) >= 2) {
           
          # x <-  genes$V1 %>% dplyr::filter(p_val_adj <= 0.05 & n == 3)
          #  x %>% dplyr::filter(gene == "LINC01122")
           
          # TODO: Fix Ing gene score values
           
          x.wide <- x %>% select(gene, individual, gene.score) %>% dplyr::filter(!gene.score == Inf) %>%
                pivot_wider(values_fill = -3,  
                            values_from = gene.score,  
                            names_from = individual, 
                            id_cols = gene)
                   
            dd  <- x.wide %>% ungroup %>% select(-gene) %>% set_rownames(value = x.wide$gene) %>% 
                  as.matrix %>%
                    dist %>% hclust %>% dendro_data

# Revert to wide dataframe for plotting.             
          x <- x.wide %>% pivot_longer(cols = 2:ncol(x.wide), 
                          values_to = "gene.score",  
                          names_to = "individual") %>% 
                dplyr::na_if(-3) %>% 
                dplyr::filter(!is.na(gene.score))  %>%
                  left_join(x,
                      by = c("gene", "individual"))  %>%
mutate(gene = factor(gene, levels = dd$labels$label),
       ) %>%
arrange(gene)
          
         }
          
       }


```

# Cluster all genes from all areas, by groups of 'n' 
(how many times they appear in area list.)
```{r}

# Error in hclust(.) : must have n >= 2 objects to cluster
genes.areas$IPC$V1 %<>% mutate(gene = str_replace(gene, "[.]", "_"))
genes <- genes.areas[[cell.type]] 

genes$V1 %>% dplyr::filter(p_val_adj <= 0.05 & n == 3) %>% 
                  mutate(gene.score = round(gene.score, 3)) 
clusterGenes(marker.genes.df = genes$V1, 
                                      n.genes = 3)


genes.clustered <- lapply(names(genes), function(area) {
  
            message(area)
            max.n <- max(genes[[area]]$n)
            message(max.n)
  
            dfs <- lapply(1:max.n, 
                          function(x) { 
              
                         message(x)
              
                         clusterGenes(marker.genes.df = genes[[area]], 
                                      n.genes = x)
                         
                          } )
                         
                         
            df <- rbindlist(dfs)  %>% 
                    mutate(individual.factor = as.factor(individual) %>% as.numeric) %>%
                    group_by(gene) %>% 
                    arrange(individual) %>% 
                    mutate(individuals = paste(individual.factor, collapse = "")) %>%
                    ungroup()
                  
# df %>% ungroup %>% select(individual, individual.factor) %>% distinct
#df$individuals %>% unique %>% sort
#factor(levels = unique(df$individuals %>% as.character %>% sort))

df %<>% 
  arrange(individuals) %>%
  mutate(# gene = factor(as.character(gene), levels = unique(as.character(gene))),
         individuals = factor(individuals, levels = df$individuals %>% unique %>% sort),
         gene.score = gene.score.x) %>%
  select(gene, n, individual , individual.factor, individuals, -gene.score.y, everything())

df$individuals %>% levels
# Biuld plot

# df %>% select(gene, n, colors.x)

df %<>% dplyr::filter(n > 1) %>%
  mutate(gene = as_factor(as.character(gene)))
                         
# df %>% arrange(as.character(individuals)) 
# df$individuals %>% levels                         
           
            
} 
)


```



```{r}
heatmaps.ipc <- 
  
genes.clustered %>% lapply(function(df) {
  
colors.x <- viridis_pal(begin = 0.2, end = 0.9)(df$n %>% max)[df %>% arrange(gene) %>% distinct(gene, n) %>% .$n]

# df %>% select(n, colors.x) %>% distinct

h <- ggplot(df) +
  geom_tile(aes(x = gene, y = individual,
                colour = gene.score.x,
                fill = gene.score.x), 
                hjust = 0.5, vjust = 0.5) +
    
   scale_fill_gradientn(aesthetics = c("colour", "fill"),
                                       na.value = "#150E37FF",
                        colors = viridis_pal(option = "magma", 
                                             begin = 0.2, end = 0.8)(100), 
                        limits = c( min(df$gene.score[! is.na(df$gene.score)]),  quantile(df$gene.score[! is.na(df$gene.score)], .95)),
                        oob = scales::squish
                        ) +
  ggtitle(df$cluster %>% unique) +
  theme_minimal() +
  theme(line = element_blank(),
        axis.text.x = element_text(size = 6, angle = 90, hjust = 1, vjust = 0.5,
                                   colour = colors.x, 
                                   margin = margin(t = -4)
                                   ),
        axis.title = element_blank(),
        aspect.ratio = .15,
        axis.ticks = element_blank()
        
        )

print(h)
})

pdf("heatmaps_genescore_IPCs.pdf", onefile = TRUE, width = 20, height = 5)
heatmaps.neurons
dev.off()
```
# legend.position = "bottom")

quantile(df$gene.score, .95, na.rm = TRUE)
g$gene.score %>% summary

t <- 


# Order of genes for combined heatmaps below.
genes.order <- list("V1" = h$data$gene)
genes.order$PFC <- h$data$gene

}
```


```{r}
ggsave(h , filename = "../violinPlots/neocortex_DEgenes_by_celltype_area/heatmap_genescore_neurons_V1.pdf", height = 4, width = 20)
```


Bin genes into categories depending on which combination of samples they appear in
```{r}

         

# Factor correspondences
df %>%  
  ungroup %>% dplyr::select(individual, individual.factor) %>% distinct(individual, individual.factor)

# Combination counts
df %>% ungroup %>% dplyr::count(n, individuals)
```

```{r}
counts <- ggplot(df) +
  geom_tile(aes(x = gene, y = 0,
                 fill = factor(n)
                 ),
                 # size = 0.1
  ) +

   theme(axis.text.x = element_text(size = 1.75, angle = 90, hjust = 1),
        axis.title = element_blank(),
        axis.text.y = element_blank()
   ) +
  
  scale_color_discrete()
        # legend.position = "bottom")

return(h)

}

levels <- data.frame(df.1$gene %>% levels,
df.2$gene %>% levels)

data.frame(df.1$gene,
df.2$gene)

lapply(list(df.1, df.2), function(x) x$gene %>% unique %>% as.character) %>% as.data.frame


patchwork::wrap_plots(h.1, h.2, byrow = TRUE)
```

ggsave(h , filename = "../violinPlots/neocortex_DEgenes_by_celltype_area/dheatmaptest.pdf", height = 4, width = 11)


  # scale_fill_viridis_c("gene.score", option = "magma", begin = 0.2, end = 0.8, limits = c(0, 15), na.value = "yellow", ) +
    # geom_label(aes(1, individual, label = n)) +
  # scale_x_discrete(limits = genes$gene) +
  # scale_y_discrete(labels = paste(genes$individual, genes$n, " ")) +

range(genes$gene.score)


markers.ct$neuron %>% str
```




## Combined: all individuals

### Neurons
```{r}
dir <- "../violinPlots/neocortex_DEgenes_by_celltype_area/markers_by_celltype_area/"
files <- paste0(dir, list.files(dir))

# Use read.delim bc 1st column is rownames (tidyr functions don't work)
markers <- lapply(files, function(x){
  
                 read.delim(x, header = FALSE) %>% 
                  set_names(c("gene", "p_val",	"avg_logFC", "pct.1", "pct.2", "p_val_adj",	"area",	"n.comps"))
            }) %>% 
            mutate(gene.ratio = pct.1 / pct.2,
                  gene.score = avg_logFC * gene.ratio
                           )
          # Name list elements according to each individual.
          set_names(value = files %>% tolower %>% str_match(pattern = ".*/(.*)_byarea") %>% .[,2]) %>%
            # https://stackoverflow.com/questions/48255351/
            # Add column with individual
            purrr::imap( ~mutate(.x, cell.type = .y))

            
```

# ------------------------------------------------------------------------------------------------------------

## Genes in common across individuals



## Top Marker genes
For each cell type, get the top marker genes for each area.
```{r}
markers %<>% lapply(function(x)
                  x %>%
                )

# write_tsv(markers, "../violinPlots/DEgenes_wholebrain_all_celltypes.txt")

# https://stackoverflow.com/a/27766224 slice_max

top.markers <- markers %>% map(dplyr::filter, n.comps >= 3) %>% 
                            map(group_by, area) %>% 
                            map(slice_max, order_by = gene.score, n = 30)



# getwrite_tsv(markers, "DEgenes_wholebrain_all_celltypes_top50.txt")
```

```{r}
s.obj <- ncx.exn

Idents(s.obj)
s.objn@meta.data %<>% set_rownames(.$cell.name)

s.obj %<>% SetIdent(value = 'cell.type')

```           


```{r}
top.markers %>% dplyr::count(area, celltype)

top.markers %<>% rbindlist

colors.area <- c("pfc"="#e72718", 
                 "motor"= "#e4840f",  
                  "somato" = "#efcf60", 
                  "parietal" = "#745cda" ,
                  "temporal" = "#ff61e8",
                  "v1" = "#1b30f3") %>% 
              tibble(category = names(.), color = .)

colors.stage <- c("early" = "grey80", "mid" = "grey50", "late" = "grey20") %>% tibble(category = names(.), color = .)

colors <- bind_rows(colors.area, colors.stage)

colors.area <- data.frame(area = names(colors.area), 
                          color = colors.area)
                          
                          
# for(celltype in celltypes) {
  

# Reorder areas


scales::show_col(colors.area$color, ncol = nrow(colors.area))

# https://forcats.tidyverse.org/reference/fct_relevel.html
ncx.exn@meta.data$area %<>% forcats::fct_relevel(colors.area$area)

top.markers$area %<>% forcats::fct_relevel(colors.structure$area)
  
  
stackedVlnMarkers <- function(ct, obj = s.obj) {
  
                        print(ct)
                        # print(region)
  
                        top.markers %<>% rbindlist
                        
                        lapply(colors.area$area, function(ctx.area){
                          
                            print(ctx.area) 
                          
                            genes.plot <- top.markers %>% dplyr::filter(cell.type == ct & area == ctx.area) %>% 
                                            arrange(desc(gene.score))
                            
                            print(genes.plot)
  
                            # canonical.gene <- celltypes.df %>% dplyr::filter(cell.type == ct) %>% .$marker
                            canonical.genes <- celltypes.df %>% dplyr::filter(cell.type %in% top.markers$cell.type) %>% .$marker                  
                            
                            if(nrow(genes.plot) > 0) {

                            p <- StackedVlnPlot(obj = s.obj, 
                                            features = c(canonical.genes, genes.plot$gene),
                                            title = paste0(ct, ": ", ctx.area, " markers"),
                                                        # genes.plot$gene[1: min(5, nrow(genes.plot))])
                                            idents = ct, 
                                            group.by = 'area',
                                            cols = colors.area$color)
                            
                              
                            ggsave(p, filename = paste0("../violinPlots/neocortex_DEgenes_by_celltype_area/vlnPlot_topDEgenes_neocortex_", ct, "_", ctx.area, ".pdf"), 
                                   device = "pdf", width = 10, height = 20, units = 'in')
                            
                            tw_sms(paste0("Done: ", ct))
                        
                        }
                          
                        }
                        
                        )
  

                        

}



p.violin <- 
  
  
  
lapply(celltypes.df$cell.type, stackedVlnMarkers)


tw_sms()





top.markers %>% arrange(area, desc(gene.score))
```

```{r}
ggsave(p.violin[[1]], filename = "../violinAstro.pdf", width = 10, height = 25, units = 'in')
```

```{r}
markers %>% dplyr::count(area, celltype)
```

```{r}
p_load(data.table)


top.markers <- markers[7]] %>% group_by(area) %>% 
  slice_max(order_by = gene.score, n = 20)


genes.plot <- top.markers %>% dplyr::filter(area == "GE" & celltype == 'radialglia')

top.markers %>% dplyr::count(celltype, area)


StackedVlnPlot(obj = wb.small, 
               features = c("AQP4", genes.plot$gene),
               idents = 'astrocyte', group.by = 'structure')
```

# Make featurePlots for each marker
```{r}
fPlots$astro <- top.markers$gene %>% lapply(function(x) { makePlot(gene = !!sym(x), 
                                                         cap = 4)
}
)


# https://stackoverflow.com/questions/39736655/plot-over-multiple-pages

m1 <- marrangeGrob(fPlots$astro, nrow=4, ncol=5)
names(m1) <- seq(1:length(m1))

for(i in names(m1)) {
  ggsave(plot = m1[[i]], 
         filename = paste0("../out/astrocyte_markers_", i, ".png"),
         device = "png",
         width = 45, height = 30, units = "in")
}


grid_arrange
ggarrange()
```

## Neurons
```{r}
markers[[6]] %<>% separate(cluster, c("celltype", "area")) %>% 
                      mutate(gene.ratio = pct.1 / pct.2,
                             gene.score = avg_logFC * gene.ratio)

top.markers <- list()
top.markers$neurons <- markers[[6]] %>% 
                        group_by(area) %>% 
                          slice_max(order_by = gene.score, n = 5)

fPlots$neurons <- top.markers$neurons$gene %>% 
                    lapply(function(x) { 
                      
                      makePlot(gene = !!sym(x), 
                               cap = 4)
                    }
                    )

m1 <- list()
m1$neurons <- marrangeGrob(fPlots$neurons, nrow=4, ncol=5)

names(m1$neurons) <- seq(1:length(m1$neurons))

for(i in names(m1$neurons)) {
  ggsave(plot = m1$neurons[[i]], 
         filename = paste0("../out/neuron_markers_", i, ".png"),
         device = "png",
         width = 45, height = 30, units = "in")
}
```
# ///////////////////////////////////////////////////////////////////////////////////////////////////////////

# fxn: stackedVlnPlot
```{r}

## remove the x-axis text and tick
## plot.margin to adjust the white space between each plot.
## ... pass any arguments to VlnPlot in Seurat

modify_vlnplot <- function(obj, 
                          feature, 
                          pt.size = 0,
                          ...) {
  
  p <- VlnPlot(obj, features = feature, pt.size = pt.size, ... )  + 
    
    ylab(feature) + 
    
    labs(title = NULL) +
    
    theme(legend.position = "none", 
          
          axis.text.x = element_blank(),
          axis.title.x = element_blank(),
          axis.ticks.x = element_blank(),
          
          axis.title.y = element_text(size = rel(0.75), angle = 0), 
          axis.text.y = element_text(size = rel(0.75)), 
          
          plot.margin = unit(c(-2, -2, -2, -2), "cm") ) 
  
  return(p)
}

## extract the max value of the y axis
extract_max<- function(p){
  
  ymax<- max(ggplot_build(p)$layout$panel_scales_y[[1]]$range$range)
  return(ceiling(ymax))
}


## main function
StackedVlnPlot<- function(obj, 
                          features,
                          pt.size = 0,
                          title,
                          # plot.margin = unit(c(0, 0, 0, 0), "cm"),
                          ...) {
  
  plot_list <- purrr::map(features, 
                          function(x) modify_vlnplot(obj = obj,
                                                     feature = x, 
                                                     ...))
  
  # Add back x-axis title to bottom plot. patchwork is going to support this?
  plot_list[[length(plot_list)]] <- plot_list[[length(plot_list)]] +
    theme(axis.text.x = element_text(size = rel(0.75), angle = 45), 
          axis.ticks.x = element_line())
  
  # change the y-axis tick to only max value 
  ymaxs <- purrr::map_dbl(plot_list, extract_max)
  plot_list<- purrr::map2(plot_list, ymaxs, function(x,y) x + 
                            scale_y_continuous(breaks = c(y)) + 
                            expand_limits(y = y))

  p <- patchwork::wrap_plots(plotlist = plot_list, ncol = 1) +
     patchwork::plot_annotation(title = title)
  
  return(p)
}
```


# //////////////////////////////////////////////////////////////////////////////////////////////////
# Heatmaps: Gene expression
Across all areas / ages

Need:
1. ncx.exn (Seurat object)
2. `markers.ct` (markers for each area by cell type)

```{r}
# Make 'group' column with area + age.
names(ncx.exn@meta.data) %<>% tolower()
ncx.exn@meta.data %<>% mutate(group = tolower(group),
                              cell.type = tolower(cell.type))
                      %>% unite("group", individual, area, remove = FALSE, sep = "-")

# Set cell.type as ident.
Idents(ncx.exn) <- 'cell.type'
# Levels: cr dividing ipc neuron opc rg

# TODO: Finx Inf values for pct.1/pct.2 gene ratios.
test <- markers.ct %>% lapply(function(x) {
  summary(x$all.indiv$p_val_adj)
   x <- x$all.indiv %>% dplyr::filter(p_val_adj <= 0.05)
   })

markers.ct %>% lapply(function(x){ 
  )
  })

markers.ct

# All PFC + V1 markers ( n>= 2), average expression across all age/area neuron groups.
avg.exp <- lapply(markers.ct, function(markers) {
    
  x <- markers$all.indiv %>% dplyr::filter(p_val_adj <= 0.05) %>%
          mutate(case_when(pct.2 == 0 ~ 0.001,
                                 TRUE ~ pct.2)
                 ) %>%
          add_count(gene, individual, name = "n.areas.per.indiv") %>% 
            arrange(gene, individual)
  
  gene.counts.1 <- x %>% distinct(gene, cluster, individual) %>% count(cluster, individual) %>% 
    pivot_wider(id_cols = cluster, names_from = individual, values_from = n)

  gene.counts.2 <- x %>% dplyr::filter(n.areas.per.indiv >= 2) %>% distinct(gene, cluster, individual) %>% count(cluster, individual) %>% 
    pivot_wider(id_cols = cluster, names_from = individual, values_from = n)

  # Get average expression
  dp <- DotPlot(object = ncx.exn,
              idents = 'neuron',
              features = x$gene %>% unique,
                          group.by = 'group',
                          scale = FALSE, 
                          dot.scale = 1)


  avg.exp <- dp$data %>% rename(gene = "features.plot", 
                                group = "id") %>% 
              left_join(x %>% dplyr::select(-X)) %>% rename(area = "cluster") %>% arrange(area, individual, gene)
  

  gene.counts.3 <- avg.exp %>% distinct(gene, area, individual) %>% 
    count(area, individual) %>% pivot_wider(id_cols = area, names_from = individual, values_from = n)
 
  avg.exp.wide <- avg.exp %>% pivot_wider(id_cols = c(gene, area, individual, n.areas.per.indiv, group),
                        names_from = group,
                        values_from = avg.exp)
  
  pct.exp.wide <- avg.exp %>% pivot_wider(id_cols = c(gene, area, individual, n.areas.per.indiv, group),
                        names_from = group,
                        values_from = pct.exp)
  
  return(list(result = avg.exp, 
              avg.exp.wide = avg.exp.wide,
              pct.exp.wide = pct.exp.wide,
              gene.counts.n1 = gene.counts.1, 
              gene.counts.n2 = gene.counts.2, 
              gene.counts.final =  gene.counts.3))
  
})

write_rds(avg.exp, "..l")
avg.exp <- read_rds( "~/Dropbox/2nd Trimester Areas Paper/Area Specific Genes/areaMarkers_byCellType_avgexp_byGroups.rds")

rstudioapi::
```

# fxn: heatmapCS
```{r}
df.quants <- df$avg.exp[df$avg.exp > 0] %>% quantile(c(0.1, 0.975))


# dp$data$features.plot %<>% factor(levels = genes.order$PFC %>% unique)
color.by <- quo(avg.exp)
colors <- c("grey20", "#182ffd","#4229e8", viridis_pal(option = "magma", 
                      begin = 0.1, end = 0.98)(10)[3:10])

colors.2 <- colors[c(1, 2,  5, 6, 7, 9, 10, 11)]
scales::show_col(colors)

colors <- colors.2

colors <- c(# "grey20",
            # "#0747fe",
            "#1a13d0",
            
            "#5d13c0",
            #"#8115c3",
            # "#d64bbe",
            
          "#f665a3",
          # "#fb6271",
          # "#fb724d",
          "#ff841a",
          # "#ff992c",
        "yellow")

scale_fill_gradientn(colours = colors, )

```

```{r}
df <- dp$data

groups <- ncx.exn@meta.data %>% 
  select(group, individual, area) %>% 
  distinct %>% as_tibble()

df %<>% left_join(groups, by = c("id" = "group"))


df %<>% arrange(individual, area) %>%
          mutate(id = factor(id, levels = unique(as.character(id))))

# df %<>% arrange(area, individual) %>%
df %<>% arrange(individual, area) %>%
          mutate(id = factor(id, levels = unique(as.character(id))),
                 avg.exp = round(avg.exp, 3),
                 avg.exp.scaled = round(avg.exp.scaled, 3)
          ) %>% rename(gene = "features.plot")

color.by <- quo(avg.exp.mm.2)
# Build plot
%>% filter(avg.exp > 0)

h1 <- ggplot(df) +
  
  geom_tile(aes(x = gene, y = id,
                
                fill = !!color.by,
                ), 
                hjust = 0.5, vjust = 0.5,
  colour = "grey10") +
  # geom_hline(yintercept = counts$area - 0.5, color = "white", size = 2) +
    geom_hline(yintercept =  counts$individual - 0.5, color = "white", size = 1.5) +
    scale_fill_gradientn("fill",
                        na.value = "grey10",
                        colors = colors, 
                        # breaks = c(-)
                        # limits = c(0, 1),  
                        #           80),
                        # oob = scales::squish,
                        # values = scales::rescale(c(df.quants[1], 2, 4, 8, 16, 24, 50))
                        # values = scales::rescale(c(-7, -3, 0, 2, 4, 6))
                        # values = scales::rescale(df$avg.exp, 
                         #                        from = c(1,10),
                          #                       to = c(0,9))
                        ) +
  # scale_y_discrete(labels = labels$individual) +
  
  # ggtitle(df$cluster %>% unique) +
  theme_minimal() +
  theme(line = element_blank(),
        axis.text.x = element_text(size = 5, angle = 90, hjust = 1, vjust = 0.5,
                                   colour = colors.x, 
                                   margin = margin(t = -4)
                                   ),
        axis.title = element_blank(),
        aspect.ratio = .5,
        axis.ticks = element_blank()
        
)

h1

h1 %>% plotly::ggplotly() %>% htmlwidgets::saveWidget("heatmap.html")

ggsave(plot = h1, "../heatmaps_neocortex_DEgenes_celltype_x_area/heatmap_geneExp_markers_PFC_byIndividual_a.pdf", device = "pdf", 
       height = 10, width = 25)

genes.order$PFC.V1 <- dplyr::combine(genes.order) %>% unique


scales::rescale(,
                           to = to,
                           from = c(min(x, na.rm = TRUE), 1.2))
```

```{r}
ggplot(df) + geom_histogram(aes(x = avg.exp), breaks =c (0.25, 1, 2, 5, 10, 15, 20, 25, 30, 35, 50, 100, 200)) +
  geom_jitter(aes(avg.exp, 2000), height = 1000)
```

```{r}
counts <- list()

counts$individual <- df %>% distinct(individual, id)
counts$individual <- match(unique(counts$individual$individual), counts$individual$individual)



counts$area <- df %>% distinct(area, id) %>% 
  match(unique(counts$area$area), counts$area$area)

labels <- list()
labels$individual <- df %>% distinct(area, id) %>% pull(id) %>%
  str_split("-", simplify = TRUE) %>% .[,1]

labels$area <- df %>% distinct(area, id) %>% pull(area)

labels$individual[counts$area] %<>% paste(labels$area[counts$area])
```

# Cluster genes: Reorder x axis
```{r}


g <- df %>% select(features.plot, id, avg.exp) %>% 
          pivot_wider(values_fill = -3,  
                      values_from = avg.exp,  
                      names_from = id, 
                      id_cols = features.plot)

# Hierarchical clustering
# Get dist matrix, run hcust, extract ordered labels
dd <- g %>% ungroup %>% 
    dplyr::select(-features.plot) %>% as.matrix %>% set_rownames(g$features.plot) %>%
       dist %>% hclust %>% dendro_data

# Revert to dataframe for plotting
# g <- g %>% pivot_longer(cols = 2:ncol(g), 
#                          values_to = "gene.score",  
#                           names_to = "individual") %>% 
#           dplyr::na_if(-3) %>% 
#           dplyr::filter(! is.na(gene.score))  %>%
#             left_join(markers.df,
#                       by = c("gene", "individual"))  %>%
# mutate(gene = factor(gene, levels = dd$labels$label)) %>%
# arrange(gene)

df$gene <- df$features.plot %>% factor(levels = dd$labels$label)
df$avg.exp <- round(df$avg.exp, 3)
```

# Reorder genes by 1st appearance
```{r}
x <- genes.PFC.order.age$gene %>% unique
df$features.plot %<>% factor(levels = x)

df$features.plot %>% levels

df %<>% rename(gene = "features.plot")
```

## Reorder individuals: y axis
```{r}
df$id %>% levels
```
```{r}
colors.area
```
```{r}
ncx.exn@meta.data %>% str
```


```{r}
df %<>% mutate(avg.exp = case_when(avg.exp <1 ~ 0,
                                  TRUE ~ avg.exp)
              )

df$avg.exp %<>% na_if(0)

df %>% ggplot() + geom_point(aes(avg.exp, avg.exp.scaled))


# min, max expression per gene
df %<>% group_by(gene, individual) %>% 
  mutate(avg.exp.mm.2 = scales::rescale(avg.exp, 
                                       # from = c(1, max(df$avg.exp)), 
                                        to = c(0,100)) %>%
                          round(., 3)
         ) %>% 
  arrange(gene)

df %>% filter(gene == "CENPV")
```

# ///////////////////////////////////////////////////////////////////////////////////////////////////////////
# DotPlots

```{r}
markers.ct

genes <- genes.areas$neurons
# List of markers split by area.
# Rename by area.
# https://community.rstudio.com/t/using-purrr-to-rename-list-objects-in-a-list-of-tibbles-based-on-the-content-of-those-tibbles/30726/
genes %<>% set_names(., 
                    value = map(.x = ., ~first(.x$cluster))
                      )


ncx.exn@meta.data %>% str
  
) %>% filter(area %in% c("PFC", "V1")) %>% count(area, individual) %>%
  ggplot() + geom_point(aes(area, individual, size = n))


ncx.exn@meta.data$area.numeric <- as.numeric(ncx.exn@meta.data$area)
ncx.exn@meta.data$individual %<>% as.factor()
ncx.exn@meta.data$split <- ncx.exn@meta.data$area %>% factor(levels = c("PFC", "V1"))
filter(cell.type == "neuron") %>% count(cell.type.area)

Idents(ncx.exn) <- 'cell.type.area'
levels(ncx.exn)

cols <- viridis_pal(option = "magma")(25)
x <- rbind(genes$PFC, genes$V1) %>% filter(cluster %in% c("PFC", "V1") & n >= 2)
x <- genes$PFC %>% filter( n >= 2)
x %>% length

dp <- DotPlot(object = ncx.exn,
              idents = c('neuron-PFC', 'neuron-V1'),
                          features = x$gene %>% unique,
                          group.by = 'cell.type.area.indiv',
                          scale = FALSE, 
                         dot.scale = 1)
                 # split.by = 'individuak')
                # cols = cols) 
# cut.default error bc there are no GW14 PFC / GW25 V1 samples

dp <- dp + scale_color_viridis_c(option = "magma", end = 0.85)
ggsave(dp , filename = "../heatmaps_neocortex_DEgenes_celltype_x_area/dotPlot_neurons_PFC_V1.pdf", height = 5, width = 30) 


                    
p <- dp$data %>% ggplot() + geom_point(aes(x = id, y = features.plot, size = pct.exp, fill = avg.exp)) +
                                    scale_size_area(max_size = 3) 


```

#//////////////////////////////////////////////////////////////////////////////////////////////////




```{r ggplot_side_colors}
ggplot_side_color_plot <- function(df,
                                   palette = NULL,
                                   scale_title = paste(type, "side colors"),
                                   type = c("column", "row"),
                                   text_angle = if (type == "column") 0 else 90,
                                   is_colors = FALSE,
                                   fontsize = 10,
                                   label_name = NULL) {

  type <- match.arg(type)
  if (is.matrix(df)) df <- as.data.frame(df)
  assert_that(is.data.frame(df))

  if (is.null(label_name)) label_name <- type

  ## Cooerce to character
  df[] <- lapply(df, as.character)

  ## TODO: Find out why names are dropped when ncol(df) == 1 (Not any more?)
  original_dim <- dim(df)

  if (is.null(palette)) palette <- default_side_colors

  ## Custom label
  if (type %in% colnames(df)) {
    stop("Having", type, "in the colnames of the side_color df will drop data!")
  }

  df[[type]] <- if (!is.null(rownames(df))) rownames(df) else 1:nrow(df)

  df[[type]] <- factor(df[[type]], levels = df[[type]], ordered = TRUE)
  df <- reshape2::melt(df, id.vars = type)
  df[["value"]] <- factor(df[["value"]])

  id_var <- colnames(df)[1]

  common_theme <- theme(
    panel.background = element_blank(),
    axis.ticks = element_blank()
  )

  ## Don't need this hack any more?
  # if(original_dim[2] > 1) {
  text_element <- element_text(angle = text_angle, hjust = 1, size = fontsize)
  # } else text_element <- element_blank()

  if (type == "column") {
    mapping <- aes_string(x = paste_aes(id_var), y = "variable", fill = "value")
    specific_theme <- theme(
      axis.text.x = element_blank(),
      axis.text.y = text_element
    )
  } else {
    mapping <- aes_string(x = "variable", y = paste_aes(id_var), fill = "value")
    specific_theme <- theme(
      axis.text.x = text_element,
      axis.text.y = element_blank(),
      legend.position = "top"
    )
  }
  theme <- list(common_theme, specific_theme)

  if (is_colors) {
    palette <- setNames(unique(df[["value"]]), unique(df[["value"]]))
  }

  if (is.function(palette)) {
    palette <- setNames(palette(nlevels(df[["value"]])), levels(df[["value"]]))
  } else if (!all(levels(factor(df[["value"]])) %in% names(palette))) {
    stop(paste0(
      "Not all levels of the ", type,
      "_side_colors are mapped in the ", type, "_side_palette"
    ))
  }

  g <- ggplot(df, mapping = mapping) +
    geom_tile() +
    xlab("") +
    ylab("") +
    scale_fill_manual(
      name = scale_title,
      breaks = levels(df[["value"]]),
      values = as.character(palette[levels(df[["value"]])])
    ) +
    theme
  return(g)
}



default_side_colors <- function(n) {
  ## Warning if n < 3 in any case
  suppressWarnings(
    if (n <= 12) {
      RColorBrewer::brewer.pal(n, "Paired")[seq_len(n)]
    } else if (n <= 20) {
      c(
        RColorBrewer::brewer.pal(12, "Paired"),
        RColorBrewer::brewer.pal(n - 12, "Set2")
      )[seq_len(n)]
    } else if (n <= 32) {
      c(
        RColorBrewer::brewer.pal(12, "Paired"),
        RColorBrewer::brewer.pal(8, "Set2"),
        RColorBrewer::brewer.pal(n - 20, "Set3")
      )[seq_len(n)]
    } else {
      colorspace::rainbow_hcl(n)
    }
  )
}
```














```{r}
%>% dplyr::filter(!item1 == item2)

# Remove duplicate comparisons
# https://community.rstudio.com/t/remove-duplicates-based-on-pairs/36608

links %>% mutate(normalized = purrr::map2_chr(item1, item2, ~paste(sort(c(.x, .y)), collapse = ""))) %>%
  dplyr::group_by(normalized) %>%
  dplyr::summarise(item1 = dplyr::first(item1),
                   item2 = dplyr::first(item2)) %>%
  dplyr::select(-normalized) %>% left_join(links, by = c("item1", "item2"))



```

```{r}
links %<>% dplyr::filter(item1 %>% str_detect("early") & item2 %>% str_detect("early"))

nodes %<>% dplyr::filter(name %in% c(as.character(links$item1), as.character(links$item2)))

sankey$rg.early <- sankeyNetwork(Links = links,
              Nodes = nodes, 
              Source = "source",
              Target = "target", 
              Value = "n", 
              NodeID = "name",
              units = "genes", # optional units name for popups
              NodeGroup = "node.group",
              LinkGroup = "link.group",
              fontSize = 12, 
              nodeWidth = 5,
              iterations = 0,
             colourScale = 'd3.scaleOrdinal().range(["#F94171", "#FFA750", "#3182BD"])'
             )

#"#9E9AC8"

saveNetwork(network = sankey$rg, "../out/sankey_rg_metaclasses_v3.html")
```


